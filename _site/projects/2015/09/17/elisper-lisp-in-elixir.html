<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="http://barakyo.github.io//css/bootstrap.css" rel="stylesheet">
        <link href="http://barakyo.github.io//css/syntax.css" rel="stylesheet">
        <script type="text/javascript" src="http://barakyo.github.io//js/jquery-1.10.2.min.js"></script>
        <script type="text/javascript" src="http://barakyo.github.io//js/collapse.js"></script>
        <title>itsbarakyo | Elisper - Parsing Lisp in Elixir</title>
    </head>
    <body>
        <div class="navbar navbar-inverse navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#mobile-links">
                      <span class="sr-only">Toggle navigation</span>
                      <span class="glyphicon glyphicon-chevron-down white"></span>
                    </button>
                    <h1>itsbarakyo</h1>
                </div>
            </div>
            <div class="collapse navbar-collapse" id="mobile-links">
                <ul class="nav navbar visible-xs">
                    <li>
                        <a href="http://barakyo.github.io//" class="btn btn-success btn-lg btn-block">HOME</a>
                    </li>
                    <li>
                        <a href="http://barakyo.github.io//personal/" class="btn btn-info btn-lg btn-block">PERSONAL</a>
                    </li>
                    <li>
                        <a href="http://barakyo.github.io//likes/" class="btn btn-like btn-lg btn-block">LIKES</a>
                    </li>
                    <li>
                        <a href="http://barakyo.github.io//notes/" class="btn btn-warning btn-lg btn-block">NOTES</a>
                    </li>
                    <li>
                        <a href="http://barakyo.github.io//projects/" class="btn btn-danger btn-lg btn-block">PROJECTS</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="navbar navbar-fixed-top hidden-xs" id="navigation">
            <div class="container">
                <div class="row">
                    <div class="col-sm-12 hidden-xs">
                        <div class="btn-toolbar">
                            <div class="btn-group btn-group-lg">
                                <a href="http://barakyo.github.io/" class="btn btn-success">HOME</a>
                            </div>
                            <div class="btn-group btn-group-lg">
                                <a href="http://barakyo.github.io//personal/" class="btn btn-info">PERSONAL</a>
                            </div>
                            <div class="btn-group btn-group-lg">
                                <a href="http://barakyo.github.io//likes/" class="btn btn-like">LIKES</a>
                            </div>
                            <div class="btn-group btn-group-lg">
                                <a href="http://barakyo.github.io//notes/" class="btn btn-warning">NOTES</a>
                            </div>
                            <div class="btn-group btn-group-lg">
                                <a href="http://barakyo.github.io//projects/" class="btn btn-danger">PROJECTS</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
<div class="container" id="post-container">
    <div class="row">
        <div class="col-sm-12">
            <blockquote class="projects">
                <p>
                    <a href="http://barakyo.github.io//projects/2015/09/17/elisper-lisp-in-elixir">
                        Elisper - Parsing Lisp in Elixir
                    </a>
                </p>
                <small>17 Sep 2015</small>
            </blockquote>
            <p><p>I recently read a really interesting and great blog post titled <a href="http://danthedev.com/2015/09/09/lisp-in-your-language/">Lisp in your Language</a> by Dan Prince. The article walked through an implementation of a subset of Lisp. After reading the post, I thought it was a great project to not only have a deeper understanding of Lisp but also of the language that the implementation is in. In fact, I was so inspired by the post, I decided that maybe I&#39;d give it a shot to write it in <a href="https://elixir-lang.org">Elixir</a>.</p>

<p>I&#39;ve been reading and messing around with Elixir for the past month or so. Elixir is a dynamically typed functional programming language built on top of the Erlang VM BEAM. The language is showing a lot of promise and even more interesting it&#39;s built on top of a very scalable platform.</p>

<p>Funny enough, besides syntax, I find Elixir very similar to Clojure (a Lisp dialect implemented on the JVM). If you&#39;re not familiar with Lisps by now, they have a very simple syntax that follows the convention</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">fn-name</span> <span class="nv">arg1</span> <span class="nv">arg2</span> <span class="nv">...</span> <span class="nv">argn</span> <span class="p">)</span></code></pre></div>

<p>With introductions out of the way, I&#39;ll try to write this as incrementally as possible. Unfortunately, I didn&#39;t make initial git commits when I was starting out, so some of the initial code is from memory.</p>

<h4>Starting Out</h4>

<p>In the blog post, Prince originally starts out by evaluating a predefined function using Javascript&#39;s <code>fn.apply</code> method. I thought this was a good way to start so I began by doing the same.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>
  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">])</span> <span class="k">do</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>Similarly to Javascipt, Elixir has an <code>apply/2</code> function which allows you to provide a function name and a list of arguments to pass to that function. The nice thing about function parameters in Elixir is that we can pattern match in them immediately, allowing us to easily pull apart the values in a list and alias them. For the parameter <code>[expr | args]</code>, we&#39;re saying bind the first value (or head) of the list to the name <code>expr</code> and the rest of the list (or tail) to the name <code>args</code> (note that <code>args</code> is also a list).</p>

<p>We can test this out through unit tests:</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElisperTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="n">test</span> <span class="s2">&quot;sum function&quot;</span> <span class="k">do</span>
    <span class="n">sum</span> <span class="p">=</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="n">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>In our first unit test, we&#39;re creating an anonymous function <code>sum</code> which we&#39;re passing to our <code>eval</code> function with the arguments 1 and 2. Note that for pattern matching our <code>expr</code> value would be the function <code>sum</code> and the <code>args</code> parameter would take the value <code>[1,2]</code>. Let&#39;s run our test and see what we get...</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mix test test/elisper_test.exs:8                                             0|10:47:19
Compiled lib/elisper.ex
Generated elisper app
Including tags: [line: &quot;8&quot;]
Excluding tags: [:test]

.

Finished in 0.07 seconds (0.07s on load, 0.00s on tests)
1 tests, 0 failures
</code></pre></div>
<h4>Mathematical and Native Operations</h4>

<p>The next step in Dan&#39;s article is the ability to pass arithmetic functions such as plus, minus, division, subtraction, etc. Dan accomplishes this by creating a Javascript object which he uses the passed in string as a key in the object&#39;s properties. We can follow a similar example in Elixir using Maps and atoms for cleaner syntax. Originally I was hoping to be able to pass in the already defined arithmetic functions in Elixir such as <code>Kernal.+/2</code> but I was unsuccessful in passing the function without it being evaluated. Our syntax for evaluating our &quot;native&quot; functions will be using atoms. Let&#39;s start by writing a test to show how this would look.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElisperTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="n">test</span> <span class="s2">&quot;sum function&quot;</span> <span class="k">do</span>
    <span class="n">sum</span> <span class="p">=</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="n">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;native addition function&quot;</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>You can see that from the new test the arguments to our eval function is now a list containing an atom <code>:+</code> to represent our native addition function with the same arguments 1 and 2. Let&#39;s update our implementation to support these native functions.</p>

<p>We&#39;ll start by defining a new eval function using a guard statement. A guard statement allows us to define a function that will only be called when a set of conditions are true. In this case, we want to create an <code>eval</code> that will be called when we pass an <code>atom</code> as the head of the list. In this function we&#39;ll define our <code>native_ops</code> map which will be a map containing a list of our native arithmetic functions.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>
  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">])</span> <span class="k">do</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>Let&#39;s run our tests to verify that what we&#39;ve done works correctly:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ mix test test/elisper_test.exs                                              0|13:54:00
..

Finished in 0.03 seconds (0.03s on load, 0.00s on tests)
2 tests, 0 failures

Randomized with seed 398982
</code></pre></div>
<h4>Handling Nested Expressions</h4>

<p>The next thing we want to do is handle nested arguments. Lisps can evaluate nested expressions in the form:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span></code></pre></div>

<p>We want to be able to handle the same expressions. Since we already have an idea of what we want to test, let&#39;s start by again writing our tests first.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElisperTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="n">test</span> <span class="s2">&quot;sum function&quot;</span> <span class="k">do</span>
    <span class="n">sum</span> <span class="p">=</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="n">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;native addition function&quot;</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;two recursive arguments&quot;</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:+</span><span class="p">,</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">4</span>
 <span class="k">end</span>

<span class="k">end</span></code></pre></div>

<p>Before attempting the implementation for evaluating nested arguments. I&#39;d like to explain the solution that I took. Before evaluating the function and its arguments in our <code>eval</code> function that calls <code>apply/2</code>, we could iterate through the list of values and determine if a list exists. If one of the values is a list, we can recursively call eval, which will format and evaluate the nested expression. Let&#39;s see what that looks like:</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>
  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">])</span> <span class="k">do</span>
    <span class="n">sub_exprs</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">fn</span>
      <span class="p">([</span><span class="n">_h</span> <span class="p">|</span> <span class="n">_t</span><span class="p">]</span> <span class="p">=</span> <span class="n">arg</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
      <span class="n">arg</span> <span class="p">-&gt;</span> <span class="n">arg</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sub_exprs</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>Lets break this down piece by piece. First we start out by enumerating over all of our arguments using <code>Enum.map</code>. As people are familiar with <code>map</code> functions in other languages, they accept a collection to iterate through and a function to apply to each argument. In this case we&#39;ve created an anonymous function that has two bodies. An awesome feature about Elixir is that anonymous functions can pattern match and have multiple bodies allowing us to handle different input. In this case, we want to specifically handle two inputs, one where the value is a list and when the supplied argument is just a single value. By pattern matching on an item with a head and tail, we can match against lists and as we&#39;ve stated before, recursively call eval on our list. If the supplied argument is just a value, we simply want to return it. Once we&#39;ve completed enumerating through and evaluating all of the arguments, we can finally call <code>apply/2</code> with our original <code>expr</code> and the newly evaluated <code>sub_exprs</code>.</p>

<h4>Conditionals</h4>

<p>One of the many features we use while programming is conditionals. To make some interesting expressions, let&#39;s add support for conditionals into our implementation. Conditionals in the Lisps take the form:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">conditional</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">true</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">false</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>

<p>We can define a simple conditional using the test:</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;if clause&quot;</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:if</span><span class="p">,</span> <span class="p">[</span><span class="err">:</span><span class="p">=,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">2</span>
<span class="k">end</span></code></pre></div>

<p>We can handle the case for <code>if</code> within our <code>native_ops</code> map. Within <code>native_ops</code>  we can simply define a function for the if key that accepts 3 arguements, a <code>conditional</code>, the <code>first</code> (or true) clause, and the <code>second</code> (or false) clause. From there we can simply evaluate our <code>conditional</code> that is passed to our function. As you may have guessed, if <code>conditional</code> evaluates to true, we simply return <code>first</code>, else we return <code>second</code>.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>
  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">if</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="k">if</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="k">do</span> <span class="n">first</span> <span class="k">else</span> <span class="n">second</span> <span class="k">end</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">])</span> <span class="k">do</span>
    <span class="n">sub_exprs</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">fn</span>
      <span class="p">([</span><span class="n">_h</span> <span class="p">|</span> <span class="n">_t</span><span class="p">]</span> <span class="p">=</span> <span class="n">arg</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
      <span class="n">arg</span> <span class="p">-&gt;</span> <span class="n">arg</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sub_exprs</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<h4>Binding Values</h4>

<p>One of the harder things that I came across was the ability to define values. Values in Lisps are bound using the <code>def</code> expression. These bound values are immutable and cannot be changed. Let&#39;s take a look at what an expression would look like:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="mi">5</span><span class="p">)</span></code></pre></div>

<p>Doing so allows us to use these values in other contexts like:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">do</span>
  <span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="mi">5</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>

<p>At this point, we have an idea for our next test and we also know what we want to implement, <code>do</code> and <code>def</code> expressions.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElisperTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="n">test</span> <span class="s2">&quot;sum function&quot;</span> <span class="k">do</span>
    <span class="n">sum</span> <span class="p">=</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="n">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;native addition function&quot;</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;two recursive arguments&quot;</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:+</span><span class="p">,</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">4</span>
 <span class="k">end</span>

 <span class="n">test</span> <span class="s2">&quot;def&quot;</span> <span class="k">do</span>
   <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">([</span><span class="ss">:do</span><span class="p">,</span> <span class="p">[</span><span class="ss">:def</span><span class="p">,</span> <span class="ss">:a</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="ss">:+</span><span class="p">,</span> <span class="ss">:a</span><span class="p">,</span> <span class="ss">:a</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">10</span>
 <span class="k">end</span>

<span class="k">end</span></code></pre></div>

<p>Now that we have our tests defined, we need to review what our implementation may look like. After trying out a number of options, I decided the best way to handle <code>def</code> clauses was to treat them separately before evaluating any expressions. I would iterate through the passed in arguments and define a <code>scope</code> which could be carried through evaluation that would hold all of the bounded values from the <code>def</code> clauses. Some of our steps:</p>

<ul>
<li>Update existing <code>eval</code> functions to accept a second <code>scope</code> parameter.</li>
<li>Implement a new <code>eval</code> function that accepts only one parameter (the expression to evaluate) where the default scope is an empty scope.</li>
<li>Before calling our <code>eval/2</code> functions, we&#39;ll update our scope with all the bounded variables to pass to our lower <code>eval/2</code> functions.</li>
<li>Handle our <code>def</code> and <code>do</code> functions.</li>
<li>Replace any instances of our variables with their bounded values.</li>
</ul>

<p><strong>Step 1:</strong> Update existing functions and define new <code>eval/1</code> function.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">if</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="k">if</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="k">do</span> <span class="n">first</span> <span class="k">else</span> <span class="n">second</span> <span class="k">end</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">],</span> <span class="n">scope</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">sub_exprs</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">fn</span>
      <span class="p">([</span><span class="n">_h</span> <span class="p">|</span> <span class="n">_t</span><span class="p">]</span> <span class="p">=</span> <span class="n">arg</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">arg</span> <span class="p">-&gt;</span> <span class="n">arg</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sub_exprs</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></div>

<p><strong>Step 2:</strong> Define new <code>eval/1</code> function.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">%{})</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">if</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="k">if</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="k">do</span> <span class="n">first</span> <span class="k">else</span> <span class="n">second</span> <span class="k">end</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">],</span> <span class="n">scope</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">sub_exprs</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">fn</span>
      <span class="p">([</span><span class="n">_h</span> <span class="p">|</span> <span class="n">_t</span><span class="p">]</span> <span class="p">=</span> <span class="n">arg</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">arg</span> <span class="p">-&gt;</span> <span class="n">arg</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sub_exprs</span><span class="p">)</span>
  <span class="k">end</span></code></pre></div>

<p><strong>Step 3:</strong> In step 3, we iterate through <code>expr</code> but this time we use the <code>reduce</code> function to output a map which contains the values bounded by the <code>def</code> expressions. We can once again use pattern matching to make our anonymous function more concise. Our first case, where we match the head of the list to <code>:def</code> we know to return a new map with our new value. In the case that we don&#39;t find a match, simply return the existing map.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>
  <span class="kd">def</span> <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">scope</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">%{},</span> <span class="k">fn</span>
      <span class="p">([</span><span class="ss">:def</span> <span class="p">|</span> <span class="n">arg</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="nc">List</span><span class="p">.</span><span class="n">first</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="nc">List</span><span class="p">.</span><span class="n">last</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
      <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">acc</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">if</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="k">if</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="k">do</span> <span class="n">first</span> <span class="k">else</span> <span class="n">second</span> <span class="k">end</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">],</span> <span class="n">scope</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">sub_exprs</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">fn</span>
      <span class="p">([</span><span class="n">_h</span> <span class="p">|</span> <span class="n">_t</span><span class="p">]</span> <span class="p">=</span> <span class="n">arg</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">arg</span> <span class="p">-&gt;</span> <span class="n">arg</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sub_exprs</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></div>

<p><strong>Step 4:</strong> Handling the <code>def</code> and <code>do</code> expressions during evaluation.
Our <code>def</code> and <code>do</code> functions are a little weird and we&#39;ll have to handle them both a little differently than our arithmetic functions. In the case of <code>do</code>, we need to take a step back and think about what the function actually does. According to the <a href="https://clojuredocs.org/clojure.core/do">Clojure Docs</a> on <code>do</code>:</p>

<blockquote>
<p>Evaluates the expressions in order and returns the value of the last. If no
expressions are supplied, returns nil.</p>
</blockquote>

<p>Following the documentation, we can simply define a function for <code>do</code> which returns the last argument that has been passed to it, that&#39;s simple enough. In the case of <code>def</code>, since we&#39;ve already handled it&#39;s purpose by binding the value to its alias within the scope, we can simply ignore it during evaluation.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Elisper</span> <span class="k">do</span>
  <span class="kd">def</span> <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">scope</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">%{},</span> <span class="k">fn</span>
      <span class="p">([</span><span class="ss">:def</span> <span class="p">|</span> <span class="n">arg</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="nc">List</span><span class="p">.</span><span class="n">first</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="nc">List</span><span class="p">.</span><span class="n">last</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
      <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">acc</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">]</span> <span class="p">=</span> <span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_atom</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">native_ops</span> <span class="p">=</span> <span class="p">%{</span>
      <span class="ss">+</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">-</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">*</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">/</span><span class="p">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="p">=</span><span class="err">:</span> <span class="k">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">if</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="k">if</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="k">do</span> <span class="n">first</span> <span class="k">else</span> <span class="n">second</span> <span class="k">end</span> <span class="k">end</span><span class="p">,</span>
      <span class="ss">do</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">b</span> <span class="k">end</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">nil</span> <span class="p">-&gt;</span> <span class="p">(</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="ss">:def</span> <span class="k">do</span>
          <span class="ss">:ok</span>
        <span class="k">else</span>
          <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">)</span>
      <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">eval</span><span class="p">([</span><span class="n">expr</span> <span class="p">|</span> <span class="n">args</span><span class="p">],</span> <span class="n">scope</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">sub_exprs</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">fn</span>
      <span class="p">([</span><span class="n">_h</span> <span class="p">|</span> <span class="n">_t</span><span class="p">]</span> <span class="p">=</span> <span class="n">arg</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="n">arg</span> <span class="p">-&gt;</span> <span class="p">(</span>
        <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">do</span>
          <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">arg</span>
          <span class="n">x</span> <span class="p">-&gt;</span> <span class="n">x</span>
        <span class="k">end</span>
      <span class="p">)</span>
    <span class="k">end</span><span class="p">)</span>
    <span class="n">apply</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sub_exprs</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<h4>Defining Functions</h4>

<p>For our last section, we&#39;ll cover how to define functions. We&#39;ll use the following syntax provided by Dan&#39;s article for defining a function:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">fn-name</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">args</span><span class="p">]</span> <span class="p">(</span><span class="nf">body</span><span class="p">))</span>
<span class="p">)</span></code></pre></div>

<p>Using this syntax, functions must be defined with <code>def</code>, this may give you a hint as to where we&#39;ll need to add it in the implementation. Similar to other <code>def</code> expressions, we&#39;ll want to be able to add our function information to the scope, so that it can be used throughout the evaluation of the rest of the expressions. Functions are a slightly different case of the <code>def</code> expression that we have, so we&#39;ll need to take that into account. Before jumping into the implementation, let&#39;s write another test.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;def fn&quot;</span> <span class="k">do</span>
 <span class="n">assert</span> <span class="p">(</span><span class="nc">Elisper</span><span class="p">.</span><span class="n">eval</span><span class="p">(</span>
    <span class="p">[</span><span class="ss">:do</span><span class="p">,</span>
     <span class="p">[</span><span class="ss">:def</span><span class="p">,</span> <span class="ss">:multi</span><span class="p">,</span>
       <span class="p">[</span><span class="ss">:fn</span><span class="p">,</span> <span class="p">[</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">],</span>
         <span class="p">[</span><span class="ss">:*</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">]</span>
       <span class="p">]</span>
     <span class="p">],</span>
     <span class="p">[</span><span class="ss">:multi</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="p">]</span>
  <span class="p">))</span> <span class="o">==</span> <span class="mi">12</span>
<span class="k">end</span></code></pre></div>

<p>One more thing to think about before we begin the implementation is how we want to add function information to our scope. I chose to create a map containing a <code>params</code> key and a <code>body</code> key to store the params and body of the function, respectively. After updating our scope should look similar to:</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="p">%{</span>
  <span class="ss">params</span><span class="p">:</span> <span class="p">[</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">],</span>
  <span class="ss">body</span><span class="p">:</span>   <span class="p">[</span><span class="ss">:*</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>

<p>Now that we have an idea of what we want to implement, let&#39;s go back to our <code>Enum.reduce</code> function.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">scope</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">%{},</span> <span class="k">fn</span>
  <span class="p">([</span><span class="ss">:def</span> <span class="p">|</span> <span class="n">arg</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="nc">List</span><span class="p">.</span><span class="n">first</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="nc">List</span><span class="p">.</span><span class="n">last</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
  <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">acc</span>
<span class="k">end</span><span class="p">)</span></code></pre></div>

<p>As we stated before, we&#39;ll want to add a case to match, we know that we still want to match for on <code>def</code> as the head of the list, but what about the tail? The tail of our list has the format <code>[fn-name, [:fn, [params], [body]]]</code>. The great thing is that we can pattern match to exactly that format. Since we&#39;ve extracted the values from the list, we can easily add a new map to the scope.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">scope</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">%{},</span> <span class="k">fn</span>
  <span class="p">([</span><span class="ss">:def</span> <span class="p">|</span> <span class="p">[</span><span class="n">func_name</span><span class="p">,</span> <span class="p">[</span><span class="ss">:fn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">]]],</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span>
    <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="p">%{</span><span class="ss">params</span><span class="p">:</span> <span class="n">params</span><span class="p">,</span> <span class="ss">body</span><span class="p">:</span> <span class="n">body</span><span class="p">})</span>
  <span class="p">)</span>
  <span class="p">([</span><span class="ss">:def</span> <span class="p">|</span> <span class="n">arg</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="nc">List</span><span class="p">.</span><span class="n">first</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span> <span class="nc">List</span><span class="p">.</span><span class="n">last</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
  <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">acc</span>
<span class="k">end</span><span class="p">)</span></code></pre></div>

<p>The next thing we&#39;ll want to do, is handle what to do when we come across <code>:fn</code> and our user created functions during evaluation. This hapens in the <code>nil</code> case when we lookup function replacements from our <code>native_ops</code> map. We&#39;ll have to modify the <code>nil</code> case a bit to get our desired behavior. First, we&#39;ll want to update our conditional to also return <code>:ok</code> when we come across a <code>:fn</code> value in our list of expressions. The next thing we&#39;ll want to do, is see if the <code>expr</code> is defined in our scope and if it is, evaluate the function with the correct parameters. Let&#39;s see what this looks like:</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">native_ops</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">nil</span> <span class="p">-&gt;</span> <span class="p">(</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="ss">:def</span> <span class="o">||</span> <span class="n">expr</span> <span class="o">==</span> <span class="ss">:fn</span> <span class="k">do</span>
      <span class="ss">:ok</span>
    <span class="k">else</span>
      <span class="k">case</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">do</span>
        <span class="p">%{</span><span class="ss">body</span><span class="p">:</span> <span class="n">body</span><span class="p">,</span> <span class="ss">params</span><span class="p">:</span> <span class="n">params</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">(</span>
          <span class="n">new_scope</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="o">|&gt;</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="k">fn</span><span class="p">({</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">},</span> <span class="n">acc</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">end</span><span class="p">)</span>
          <span class="n">eval</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">new_scope</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="no">nil</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="p">)</span>
  <span class="n">func</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
<span class="k">end</span></code></pre></div>

<p>Using the <code>Map.get</code> function we&#39;ll lookup the <code>expr</code> in our <code>scope</code>. If a case matches the pattern, <code>%{body: body, params: params}</code>, that we defined for our function entries, we need to evaluate the user defined function. Before simply passing the <code>body</code> to our <code>eval</code> function, we&#39;ll need to update our <code>scope</code> with the new values. To do so, we&#39;ll first use <code>Enum.zip</code> to create a list of tuples containing the parameter name and the value associated with it. In the case of our test, our zipped list would look something like: <code>[{:x, 3}, {:y, 4}]</code>. Using this list we can once again use <code>Enum.reduce</code> to create a new scope that adds the key/value pair of the tuple to our existing scope. Using our new scope, so cleverly titled <code>new_scope</code>, and our <code>body</code> to finally evaluate the expression.</p>

<p>We can now re-run all of our tests:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mix test test/elisper_test.exs                                              0|10:06:43
......

Finished in 0.04 seconds (0.04s on load, 0.00s on tests)
6 tests, 0 failures

Randomized with seed 969698
</code></pre></div>
<h4>Conclusion</h4>

<p>I hope that you enjoyed this blog post and maybe I&#39;ve peaked your interest to take a look into Elixir. I&#39;ve put the code on <a href="https://github.com/barakyo/elisper">Github</a> to mess around with. Pull requests are welcomed if you want to mess around and add features or clean up the code for me to learn from. :)</p>
</p>
            <hr />
        </div>
    </div>
</div>